import type { AxiosError } from 'axios';
/** General Errors */
export type GetProcessError = ProcessNotFound;
/** Passkey Management Errors */
export type PasskeyListError = UnknownError;
export type PasskeyDeleteError = UnknownError;
export declare class CorbadoError extends Error {
    #private;
    recoverable: boolean;
    ignore: boolean;
    constructor(recoverable: boolean, ignore: boolean);
    get translatedMessage(): string;
    set translatedMessage(message: string);
    static missingInit(): CorbadoError;
    static invalidConfig(): CorbadoError;
    static ignore(): CorbadoError;
    static conditionalUINotSupported(): CorbadoError;
    static fromAxiosError(error: AxiosError): RecoverableError | NonRecoverableError;
    static fromDOMException(e: DOMException): CorbadoError;
    static fromUnknownFrontendError(e: unknown): CorbadoError;
    static noPasskeyAvailable(): CorbadoError;
    static onlyHybridPasskeyAvailable(): CorbadoError;
}
/**
 * RecoverableError can be handled by either showing an error message to the user, by retrying the operation or by calling a fallback function.
 * Most errors fall into this category.
 */
export declare class RecoverableError extends CorbadoError {
    constructor(name: string);
    getTranslationKey(): string;
    static unknown(): RecoverableError;
}
/**
 * NonRecoverableErrors are only thrown when there is a big problem with the application (e.g. the application is misconfigured).
 * We can not recover from such an error.
 * Therefore, these errors are handled by showing a central error page.
 * Only a few errors should fall into this category.
 *
 * We don't offer translations for NonRecoverableError in general.
 * Only the generic version of the NonRecoverableError can be translated because it is intended to be shown to the end user.
 * The more detailed versions of NonRecoverableError are only shown to developers so there is no need to translate them.
 */
export declare class NonRecoverableError extends CorbadoError {
    readonly message: string;
    readonly link?: string;
    readonly requestId?: string;
    constructor(message: string, link?: string, requestId?: string);
    static unhandledFrontendError(message: string): NonRecoverableError;
    static unhandledBackendError(code: string, message?: string): NonRecoverableError;
}
export declare class UserAlreadyExistsError extends RecoverableError {
    constructor();
}
export declare class PasskeyAlreadyExistsError extends RecoverableError {
    constructor();
}
export declare class PasskeysNotSupported extends RecoverableError {
    constructor();
}
export declare class UnknownUserError extends RecoverableError {
    constructor();
}
export declare class NoPasskeyAvailableError extends RecoverableError {
    constructor();
}
export declare class OnlyHybridPasskeyAvailableError extends RecoverableError {
    constructor();
}
export declare class InvalidPasskeyError extends RecoverableError {
    constructor();
}
export declare class PasskeyChallengeCancelledError extends RecoverableError {
    constructor();
}
export declare class InvalidFullnameError extends RecoverableError {
    constructor();
}
export declare class InvalidEmailError extends RecoverableError {
    constructor();
}
export declare class InvalidOtpInputError extends RecoverableError {
    constructor();
}
export declare class InvalidTokenInputError extends RecoverableError {
    constructor();
}
export declare class ConditionalUiNotSupportedError extends RecoverableError {
    constructor();
}
export declare class ConditionalUiUnconfirmedCredential extends RecoverableError {
    constructor();
}
export declare class UnknownError extends RecoverableError {
    constructor();
}
export declare class ProcessNotFound extends RecoverableError {
    constructor();
}
