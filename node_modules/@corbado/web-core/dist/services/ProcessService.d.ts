import type { AxiosResponse } from 'axios';
import type { Result } from 'ts-results';
import type { AuthType, LoginIdentifier, PasskeyOperation, ProcessResponse, SocialProviderType } from '../api/v2';
import { BlockType } from '../api/v2';
import { EmailVerifyFromUrl } from '../models/emailVerifyFromUrl';
import type { LastIdentifier } from '../models/lastIdentifier';
import { CorbadoError } from '../utils';
export declare class ProcessService {
    #private;
    constructor(projectId: string, timeout: number | undefined, isPreviewMode: boolean, frontendApiUrlSuffix: string);
    init(abortController: AbortController, frontendPreferredBlockType?: BlockType, isDebug?: boolean): Promise<Result<ProcessResponse, CorbadoError>>;
    clearProcess(): void;
    initEmailVerifyFromUrl(): Result<EmailVerifyFromUrl | null, CorbadoError>;
    wrapWithErr<T>(callback: () => Promise<AxiosResponse<T>>): Promise<Result<T, CorbadoError>>;
    finishAuthProcess(): Promise<Result<ProcessResponse, CorbadoError>>;
    resetAuthProcess(): Promise<Result<ProcessResponse, CorbadoError>>;
    initSignup(identifiers: LoginIdentifier[], fullName?: string): Promise<Result<ProcessResponse, CorbadoError>>;
    initLogin(identifierValue: string, isPhone: boolean): Promise<Result<ProcessResponse, CorbadoError>>;
    skipBlock(): Promise<Result<ProcessResponse, CorbadoError>>;
    startPasskeyAppend(): Promise<Result<ProcessResponse, CorbadoError>>;
    finishPasskeyAppend(signedChallenge: string): Promise<Result<ProcessResponse, CorbadoError>>;
    startPasskeyLogin(): Promise<Result<ProcessResponse, CorbadoError>>;
    finishPasskeyLogin(signedChallenge: string): Promise<Result<ProcessResponse, CorbadoError>>;
    finishPasskeyMediation(signedChallenge: string): Promise<Result<ProcessResponse, CorbadoError>>;
    startEmailCodeVerification(): Promise<Result<ProcessResponse, CorbadoError>>;
    finishEmailCodeVerification(code: string): Promise<Result<ProcessResponse, CorbadoError>>;
    startEmailLinkVerification(): Promise<Result<ProcessResponse, CorbadoError>>;
    finishEmailLinkVerification(abortController: AbortController, code: string, isNewDevice: boolean): Promise<Result<ProcessResponse, CorbadoError>>;
    getVerificationStatus(): Promise<Result<ProcessResponse, CorbadoError>>;
    updateEmail(email: string): Promise<Result<ProcessResponse, CorbadoError>>;
    updatePhone(phone: string): Promise<Result<ProcessResponse, CorbadoError>>;
    updateUsername(username: string): Promise<Result<ProcessResponse, CorbadoError>>;
    startPhoneOtpVerification(): Promise<Result<ProcessResponse, CorbadoError>>;
    finishPhoneOtpVerification(code: string): Promise<Result<ProcessResponse, CorbadoError>>;
    startSocialVerification(providerType: SocialProviderType, redirectUrl: string, authType: AuthType): Promise<Result<ProcessResponse, CorbadoError> | null>;
    finishSocialVerification(abortController: AbortController): Promise<Result<ProcessResponse, CorbadoError>>;
    appendPasskey(): Promise<Result<ProcessResponse, CorbadoError>>;
    loginWithPasskey(skipIfOnlyHybrid?: boolean): Promise<Result<ProcessResponse, CorbadoError>>;
    isConditionalUISupported(): Promise<boolean>;
    loginWithPasskeyChallenge(challenge: string): Promise<Result<ProcessResponse, CorbadoError>>;
    dropPasskeyAppendShown(): void;
    dropLastIdentifier: (passkeyOperations: PasskeyOperation | undefined) => void;
    getLastIdentifier: () => LastIdentifier | undefined;
    dispose(): void;
    skipPasskeyAppendAfterHybrid(skip: boolean): void;
}
